From c55fd96207e436e50880176b9d7b63616a0a0a01 Mon Sep 17 00:00:00 2001
From: Yongjia Zhang <zhang_yong_jia@126.com>
Date: Thu, 8 May 2014 18:21:37 +0800
Subject: [PATCH] Milestone: Add if-else-endif instruction to structured blocks

Signed-off-by: Yongjia Zhang <yongjia.zhang@intel.com>
---
 backend/src/CMakeLists.txt                 |   2 +
 backend/src/backend/context.cpp            |  98 ++-
 backend/src/backend/context.hpp            |   1 +
 backend/src/backend/gen_context.cpp        |  13 +-
 backend/src/backend/gen_encoder.cpp        |  10 +-
 backend/src/backend/gen_encoder.hpp        |   2 +
 backend/src/backend/gen_insn_selection.cpp | 116 +++-
 backend/src/backend/gen_insn_selection.hxx |   1 +
 backend/src/ir/function.cpp                |  23 +-
 backend/src/ir/function.hpp                |  24 +-
 backend/src/ir/instruction.cpp             |  22 +-
 backend/src/ir/instruction.hpp             |   6 +
 backend/src/ir/instruction.hxx             |   3 +
 backend/src/ir/liveness.cpp                |   4 +
 backend/src/ir/structural_analysis.cpp     | 965 +++++++++++++++++++++++++++++
 backend/src/ir/structural_analysis.hpp     | 250 ++++++++
 backend/src/llvm/llvm_to_gen.cpp           |  14 +
 17 files changed, 1502 insertions(+), 52 deletions(-)
 create mode 100644 backend/src/ir/structural_analysis.cpp
 create mode 100644 backend/src/ir/structural_analysis.hpp

diff --git a/backend/src/CMakeLists.txt b/backend/src/CMakeLists.txt
index 67ea371..1226db5 100644
--- a/backend/src/CMakeLists.txt
+++ b/backend/src/CMakeLists.txt
@@ -135,6 +135,8 @@ else (GBE_USE_BLOB)
     ir/value.hpp
     ir/lowering.cpp
     ir/lowering.hpp
+    ir/structural_analysis.cpp
+    ir/structural_analysis.hpp
     backend/context.cpp
     backend/context.hpp
     backend/program.cpp
diff --git a/backend/src/backend/context.cpp b/backend/src/backend/context.cpp
index db968c3..c6c3b7f 100644
--- a/backend/src/backend/context.cpp
+++ b/backend/src/backend/context.cpp
@@ -510,40 +510,93 @@ namespace gbe
 
   void Context::buildJIPs(void) {
     using namespace ir;
-
     // Linearly store the branch target for each block and its own label
     const LabelIndex noTarget(fn.labelNum());
     vector<std::pair<LabelIndex, LabelIndex>> braTargets;
-    int32_t curr = 0, blockNum = fn.blockNum();
-    braTargets.resize(blockNum);
-
+    int32_t curr = 0;
     // If some blocks are unused we mark them as such by setting their own label
     // as "invalid" (== noTarget)
+    int blockCount = 0;
+    fn.foreachBlock([&](const BasicBlock &bb)
+    {
+      if(bb.belongToStructure && bb.isStructureExit)
+        blockCount++;
+      else if(!bb.belongToStructure)
+        blockCount++;
+    });
+    braTargets.resize(blockCount);
+
+    LabelIndex structureExitLabel;
+    LabelIndex structureEntryLabel;
+    bool flag;
+    set<uint32_t> pos;
+    map<uint32_t, LabelIndex> exitMap;
+    map<uint32_t, LabelIndex> entryMap;
     for (auto &bb : braTargets) bb = std::make_pair(noTarget, noTarget);
     fn.foreachBlock([&](const BasicBlock &bb) {
-      const LabelIndex ownLabel = bb.getLabelIndex();
-      const Instruction *last = bb.getLastInstruction();
-      if (last->getOpcode() != OP_BRA)
-        braTargets[curr++] = std::make_pair(ownLabel, noTarget);
-      else {
-        const BranchInstruction *bra = cast<BranchInstruction>(last);
-        braTargets[curr++] = std::make_pair(ownLabel, bra->getLabelIndex());
+      LabelIndex ownLabel;
+      Instruction *last;
+      flag = false;
+      if(bb.belongToStructure && !bb.isStructureExit)
+      {
+        last = bb.getLastInstruction();
+        if(last->getOpcode() == OP_BRA)
+        {
+          BranchInstruction *bra = cast<BranchInstruction>(last);
+          JIPs.insert(std::make_pair(bra, bra->getLabelIndex()));
+        }
+        return;
+      }
+      else
+      {
+        if(bb.belongToStructure && bb.isStructureExit)
+        {
+          ownLabel = (bb.matchingStructureEntry)->getLabelIndex();
+          last = bb.getLastInstruction();
+          structureExitLabel = bb.getLabelIndex();
+          structureEntryLabel = ownLabel;
+          flag = true;
+        }
+        else
+        {
+          ownLabel = bb.getLabelIndex();
+          last = bb.getLastInstruction();
+        }
+        if (last->getOpcode() != OP_BRA)
+        {
+          braTargets[curr++] = std::make_pair(ownLabel, noTarget);
+          if(flag)
+          {
+            pos.insert(curr-1);
+            exitMap[curr-1] = structureExitLabel;
+            entryMap[curr-1] = structureEntryLabel;
+          }
+        }
+        else {
+          const BranchInstruction *bra = cast<BranchInstruction>(last);
+          braTargets[curr++] = std::make_pair(ownLabel, bra->getLabelIndex());
+          if(flag)
+          {
+            exitMap[curr-1] = structureExitLabel;
+            entryMap[curr-1] = structureEntryLabel;
+            pos.insert(curr-1);
+          }
+        }
       }
     });
-
     // Backward jumps are special. We must insert the label of the next block
     // when we hit the "DO" i.e. the target label of the backward branch (as in
     // do { } while) . So, we store the bwd jumps per targets
     // XXX does not use custom allocator
     std::multimap<LabelIndex, LabelIndex> bwdTargets;
-    for (int32_t blockID = 0; blockID < blockNum; ++blockID) {
+    for (int32_t blockID = 0; blockID <curr; ++blockID) {
       const LabelIndex ownLabel = braTargets[blockID].first;
       const LabelIndex target = braTargets[blockID].second;
       if (ownLabel == noTarget) continue; // unused block
       if (target == noTarget) continue; // no branch
       if (target <= ownLabel) { // This is a backward jump
         // Last block is just "RET". So, it cannot be the last block
-        GBE_ASSERT(blockID < blockNum - 1);
+        GBE_ASSERT(blockID < curr - 1);
         const LabelIndex fallThrough = braTargets[blockID+1].first;
         bwdTargets.insert(std::make_pair(target, fallThrough));
       }
@@ -551,15 +604,21 @@ namespace gbe
 
     // Stores the current forward targets
     set<LabelIndex> fwdTargets;
-
     // Now retraverse the blocks and figure out all JIPs
-    for (int32_t blockID = 0; blockID < blockNum; ++blockID) {
+    for (int32_t blockID = 0; blockID <curr; ++blockID) {
+
       const LabelIndex ownLabel = braTargets[blockID].first;
       const LabelIndex target = braTargets[blockID].second;
-      const BasicBlock &bb = fn.getBlock(ownLabel);
-      const Instruction *label = bb.getFirstInstruction();
+      LabelIndex tmp;
+      if(pos.find(blockID)!=pos.end())
+        tmp = exitMap[blockID];
+      else
+        tmp = ownLabel;
+      BasicBlock &bb = fn.getBlock(tmp);
+      Instruction *label = bb.getFirstInstruction();
+      if(pos.find(blockID)!=pos.end())
+        label = fn.getBlock(entryMap[blockID]).getFirstInstruction();
       const Instruction *bra = bb.getLastInstruction();
-
       // Expires the branches that point to us (if any)
       auto it = fwdTargets.find(ownLabel);
       if (it != fwdTargets.end()) fwdTargets.erase(it);
@@ -589,6 +648,7 @@ namespace gbe
       auto jip = fwdTargets.lower_bound(LabelIndex(0));
       JIPs.insert(std::make_pair(bra, *jip));
     }
+
   }
 
   void Context::handleSLM(void) {
diff --git a/backend/src/backend/context.hpp b/backend/src/backend/context.hpp
index 2a37a0e..db723f1 100644
--- a/backend/src/backend/context.hpp
+++ b/backend/src/backend/context.hpp
@@ -21,6 +21,7 @@
 #define __GBE_CONTEXT_HPP__
 
 #include "ir/instruction.hpp"
+#include "ir/function.hpp"
 #include "backend/program.h"
 #include "sys/set.hpp"
 #include "sys/map.hpp"
diff --git a/backend/src/backend/gen_context.cpp b/backend/src/backend/gen_context.cpp
index 7a0a806..545ea43 100644
--- a/backend/src/backend/gen_context.cpp
+++ b/backend/src/backend/gen_context.cpp
@@ -120,6 +120,7 @@ namespace gbe
       const LabelPair labelPair = pair.first;
       const int32_t insnID = pair.second;
       const int32_t jip = labelPos.find(labelPair.l0)->second;
+
       const int32_t uip = labelPos.find(labelPair.l1)->second;
       if (((jip - insnID) > 32767 || (jip - insnID) < -32768) ||
           ((uip - insnID) > 32768 || (uip - insnID) < -32768)) {
@@ -127,7 +128,7 @@ namespace gbe
         errCode = OUT_OF_RANGE_IF_ENDIF; 
         return false;
       }
-      p->patchJMPI(insnID, (((uip - insnID)) << 16) | ((jip - insnID)));
+      p->patchJMPI(insnID, ((uip - insnID) << 16) | (0x0000ffff & (jip - insnID)));
     }
     return true;
   }
@@ -193,6 +194,7 @@ namespace gbe
 
   void GenContext::emitLabelInstruction(const SelectionInstruction &insn) {
     const ir::LabelIndex label(insn.index);
+   // std::cout<<"labelPos.insert "<<label<<" "<<p->store.size()<<std::endl;
     this->labelPos.insert(std::make_pair(label, p->store.size()));
   }
 
@@ -242,6 +244,15 @@ namespace gbe
           p->IF(src);
         }
         break;
+      case SEL_OP_ELSE:
+        {
+          const ir::LabelIndex label(insn.index), label1(insn.index);
+          const LabelPair labelPair(label, label1);
+          const GenRegister src = ra->genReg(insn.src(0));
+          this->branchPos3.push_back(std::make_pair(labelPair, p->store.size()));
+          p->ELSE(src);
+        }
+        break;
       default: NOT_IMPLEMENTED;
     }
   }
diff --git a/backend/src/backend/gen_encoder.cpp b/backend/src/backend/gen_encoder.cpp
index abb04e6..bcffdb9 100644
--- a/backend/src/backend/gen_encoder.cpp
+++ b/backend/src/backend/gen_encoder.cpp
@@ -865,7 +865,7 @@ namespace gbe
       curr.noMask = 1;
       MOV(r0, src0);
       MOV(GenRegister::suboffset(r0, 4), GenRegister::suboffset(src0, 4));
-      curr.predicate = GEN_PREDICATE_NORMAL;
+      curr.noMask = 0;
       curr.quarterControl = 0;
       curr.nibControl = 0;
       MOV(dest, r);
@@ -879,7 +879,7 @@ namespace gbe
         curr.noMask = 1;
         MOV(r0, GenRegister::suboffset(src0, 8));
         MOV(GenRegister::suboffset(r0, 4), GenRegister::suboffset(src0, 12));
-        curr.predicate = GEN_PREDICATE_NORMAL;
+        curr.noMask = 0;
         curr.quarterControl = 1;
         curr.nibControl = 0;
         MOV(GenRegister::suboffset(dest, 8), r);
@@ -1020,6 +1020,7 @@ namespace gbe
   }
 
   ALU2_BRA(IF)
+  ALU2_BRA(ELSE)
   ALU2_BRA(ENDIF)
   ALU2_BRA(BRD)
   ALU2_BRA(BRC)
@@ -1031,7 +1032,8 @@ namespace gbe
                insn.header.opcode == GEN_OPCODE_BRD  ||
                insn.header.opcode == GEN_OPCODE_ENDIF ||
                insn.header.opcode == GEN_OPCODE_IF ||
-               insn.header.opcode == GEN_OPCODE_BRC);
+               insn.header.opcode == GEN_OPCODE_BRC ||
+               insn.header.opcode == GEN_OPCODE_ELSE);
 
     if (insn.header.opcode != GEN_OPCODE_JMPI || (jumpDistance > -32769 && jumpDistance < 32768))  {
            if (insn.header.opcode == GEN_OPCODE_IF) {
@@ -1041,6 +1043,8 @@ namespace gbe
            else if (insn.header.opcode == GEN_OPCODE_JMPI) {
              jumpDistance = (jumpDistance - 2)* jump_width;
            }
+           else if(insn.header.opcode == GEN_OPCODE_ENDIF)
+             jumpDistance += 2;
 
            this->setSrc1(&insn, GenRegister::immd(jumpDistance));
     } else if ( insn.header.predicate_control == GEN_PREDICATE_NONE ) {
diff --git a/backend/src/backend/gen_encoder.hpp b/backend/src/backend/gen_encoder.hpp
index 02661d3..4090b7c 100644
--- a/backend/src/backend/gen_encoder.hpp
+++ b/backend/src/backend/gen_encoder.hpp
@@ -152,6 +152,8 @@ namespace gbe
     void JMPI(GenRegister src, bool longjmp = false);
     /*! IF indexed instruction */
     void IF(GenRegister src);
+    /*! ELSE indexed instruction */
+    void ELSE(GenRegister src);
     /*! ENDIF indexed instruction */
     void ENDIF(GenRegister src);
     /*! BRC indexed instruction */
diff --git a/backend/src/backend/gen_insn_selection.cpp b/backend/src/backend/gen_insn_selection.cpp
index 3530d2c..d9cae0d 100644
--- a/backend/src/backend/gen_insn_selection.cpp
+++ b/backend/src/backend/gen_insn_selection.cpp
@@ -102,6 +102,7 @@
 #include "ir/profile.hpp"
 #include "sys/cvar.hpp"
 #include "sys/vector.hpp"
+#include "ir/structural_analysis.hpp"
 #include <algorithm>
 
 namespace gbe
@@ -538,8 +539,10 @@ namespace gbe
     int JMPI(Reg src, ir::LabelIndex target, ir::LabelIndex origin);
     /*! IF indexed instruction */
     void IF(Reg src, ir::LabelIndex jip, ir::LabelIndex uip);
+    /*! ELSE indexed instruction */
+    void ELSE(Reg src, ir::LabelIndex jip, ir::LabelIndex elseLabel);
     /*! ENDIF indexed instruction */
-    void ENDIF(Reg src, ir::LabelIndex jip);
+    void ENDIF(Reg src, ir::LabelIndex jip, ir::LabelIndex endifLabel = ir::LabelIndex(0));
     /*! BRD indexed instruction */
     void BRD(Reg src, ir::LabelIndex jip);
     /*! BRC indexed instruction */
@@ -1040,8 +1043,19 @@ namespace gbe
     insn->index1 = uint16_t(uip);
   }
 
-  void Selection::Opaque::ENDIF(Reg src, ir::LabelIndex jip) {
-    this->block->endifLabel = this->newAuxLabel();
+  void Selection::Opaque::ELSE(Reg src, ir::LabelIndex jip, ir::LabelIndex elseLabel) {
+
+    SelectionInstruction *insn = this->appendInsn(SEL_OP_ELSE, 0, 1);
+    insn->src(0) = src;
+    insn->index = uint16_t(jip);
+    this->LABEL(elseLabel);
+  }
+
+  void Selection::Opaque::ENDIF(Reg src, ir::LabelIndex jip, ir::LabelIndex endifLabel) {
+    if(endifLabel == 0)
+      this->block->endifLabel = this->newAuxLabel();
+    else
+      this->block->endifLabel = endifLabel;
     this->LABEL(this->block->endifLabel);
     SelectionInstruction *insn = this->appendInsn(SEL_OP_ENDIF, 0, 1);
     insn->src(0) = src;
@@ -1436,7 +1450,7 @@ namespace gbe
         insn.hasSideEffect() ||
         insn.isMemberOf<ir::BranchInstruction>() ||
         insn.isMemberOf<ir::LabelInstruction>())
-    return true;
+      return true;
 
     // No side effect, not a branch and no destination? Impossible
     GBE_ASSERT(insn.getDstNum() == 1);
@@ -1450,7 +1464,6 @@ namespace gbe
     if (liveOut.contains(reg))
       return true;
 
-    // The instruction is only used in the current basic block
     return false;
   }
 
@@ -1473,7 +1486,6 @@ namespace gbe
     const_cast<BasicBlock&>(bb).foreach([&](const Instruction &insn) {
       if (insn.getOpcode() == OP_SYNC)
         this->block->hasBarrier = true;
-
       // Build a selectionDAG node for instruction
       SelectionDAG *dag = this->newSelectionDAG(insn);
 
@@ -1536,6 +1548,7 @@ namespace gbe
     for (int32_t insnID = insnNum-1; insnID >= 0; --insnID) {
       // Process all possible patterns for this instruction
       SelectionDAG &dag = *insnDAG[insnID];
+
       if (dag.isRoot) {
         const ir::Instruction &insn = dag.insn;
         const ir::Opcode opcode = insn.getOpcode();
@@ -1569,13 +1582,31 @@ namespace gbe
           this->block->isLargeBlock = true;
         }
 
+#ifdef TRANSFORM_UNSTRUCTURE
+        const ir::BasicBlock *bb = insn.getParent();
+
+        needEndif = needEndif && bb->needEndif;
         if (needEndif) {
+          if(!bb->needIf) {
+            this->ENDIF(GenRegister::immd(0), bb->endifLabel, bb->endifLabel);
+            needEndif = false;
+          }
+          else {
+            const ir::BasicBlock *curr = insn.getParent();
+            const ir::BasicBlock *next = curr->getNextBlock();
+            this->ENDIF(GenRegister::immd(0), next->getLabelIndex());
+            needEndif = false;
+          }
+        }
+#endif
+#ifndef TRANSFORM_UNSTRUCTURE
+        if(needEndif) {
           const ir::BasicBlock *curr = insn.getParent();
           const ir::BasicBlock *next = curr->getNextBlock();
           this->ENDIF(GenRegister::immd(0), next->getLabelIndex());
           needEndif = false;
         }
-
+#endif
         // Output the code in the current basic block
         this->endBackwardGeneration();
       }
@@ -3396,6 +3427,11 @@ namespace gbe
       GBE_ASSERTM(label < GEN_MAX_LABEL, "We reached the maximum label number which is reserved for barrier handling");
       sel.LABEL(label);
 
+#ifdef TRANSFORM_UNSTRUCTURE
+      if(!insn.getParent()->needIf)
+        return true;
+#endif
+
       // Do not emit any code for the "returning" block. There is no need for it
       if (insn.getParent() == &sel.ctx.getFunction().getBottomBlock())
         return true;
@@ -3466,7 +3502,14 @@ namespace gbe
         }
         sel.push();
           sel.curr.predicate = GEN_PREDICATE_NORMAL;
-          sel.IF(GenRegister::immd(0), sel.block->endifLabel, sel.block->endifLabel);
+#ifdef TRANSFORM_UNSTRUCTURE
+          if(!insn.getParent()->needEndif && insn.getParent()->needIf) {
+            ir::LabelIndex label = insn.getParent()->endifLabel;
+            sel.IF(GenRegister::immd(0), label, label);
+          }
+          else
+#endif
+            sel.IF(GenRegister::immd(0), sel.block->endifLabel, sel.block->endifLabel);
         sel.pop();
       }
 
@@ -3658,9 +3701,17 @@ namespace gbe
       } else {
         // Update the PcIPs
         const LabelIndex jip = sel.ctx.getLabelIndex(&insn);
-        sel.MOV(ip, GenRegister::immuw(uint16_t(dst)));
-        if (!sel.block->hasBarrier)
-          sel.ENDIF(GenRegister::immd(0), nextLabel);
+        if(insn.getParent()->needEndif)
+          sel.MOV(ip, GenRegister::immuw(uint16_t(dst)));
+
+        if (!sel.block->hasBarrier) {
+#ifdef TRANSFORM_UNSTRUCTURE
+          if(insn.getParent()->needEndif && !insn.getParent()->needIf)
+            sel.ENDIF(GenRegister::immd(0), insn.getParent()->endifLabel, insn.getParent()->endifLabel);
+          else if(insn.getParent()->needEndif)
+#endif
+            sel.ENDIF(GenRegister::immd(0), nextLabel);
+        }
         sel.block->endifOffset = -1;
         if (nextLabel == jip) return;
         // Branch to the jump target
@@ -3683,6 +3734,7 @@ namespace gbe
       const Function &fn = sel.ctx.getFunction();
       const BasicBlock &bb = fn.getBlock(src);
       const LabelIndex jip = sel.ctx.getLabelIndex(&insn);
+      //LabelIndex jip = insn.getLabelIndex();
       const LabelIndex label = bb.getLabelIndex();
       const uint32_t simdWidth = sel.ctx.getSimdWidth();
       GBE_ASSERT(bb.getNextBlock() != NULL);
@@ -3716,10 +3768,18 @@ namespace gbe
       } else {
         const LabelIndex next = bb.getNextBlock()->getLabelIndex();
         // Update the PcIPs
-        sel.MOV(ip, GenRegister::immuw(uint16_t(dst)));
+        if(insn.getParent()->needEndif)
+          sel.MOV(ip, GenRegister::immuw(uint16_t(dst)));
         sel.block->endifOffset = -1;
-        if (!sel.block->hasBarrier)
-          sel.ENDIF(GenRegister::immd(0), next);
+        if (!sel.block->hasBarrier) {
+#ifdef TRANSFORM_UNSTRUCTURE
+          if(insn.getParent()->needEndif && !insn.getParent()->needIf)
+            sel.ENDIF(GenRegister::immd(0), insn.getParent()->endifLabel, insn.getParent()->endifLabel);
+          else if(insn.getParent()->needEndif)
+#endif
+
+            sel.ENDIF(GenRegister::immd(0), next);
+        }
         // Branch to the jump target
         sel.push();
           sel.curr.execWidth = 1;
@@ -3752,6 +3812,34 @@ namespace gbe
         else
           this->emitForwardBranch(sel, insn, dst, src);
         sel.pop();
+      }
+      else if(opcode == OP_IF) {
+        const Register pred = insn.getPredicateIndex();
+        const LabelIndex jip = insn.getLabelIndex();
+        LabelIndex uip;
+        if(insn.getParent()->matchingEndifLabel != 0)
+          uip = insn.getParent()->matchingEndifLabel;
+        else
+          uip = jip;
+        sel.push();
+          sel.curr.physicalFlag = 0;
+          sel.curr.flagIndex = (uint64_t)pred;
+          sel.curr.externFlag = 1;
+          sel.curr.inversePredicate = 1;
+          sel.curr.predicate = GEN_PREDICATE_NORMAL;
+          sel.IF(GenRegister::immd(0), jip, uip);
+          sel.curr.inversePredicate = 0;
+        sel.pop();
+      } else if(opcode == OP_ENDIF) {
+        const LabelIndex label = insn.getLabelIndex();
+        sel.push();
+          sel.curr.noMask = 1;
+          sel.curr.predicate = GEN_PREDICATE_NONE;
+          sel.ENDIF(GenRegister::immd(0), label, label);
+        sel.pop();
+      } else if(opcode == OP_ELSE) {
+        const LabelIndex label = insn.getLabelIndex();
+        sel.ELSE(GenRegister::immd(0), label, insn.getParent()->thisElseLabel);
       } else
         NOT_IMPLEMENTED;
 
diff --git a/backend/src/backend/gen_insn_selection.hxx b/backend/src/backend/gen_insn_selection.hxx
index ddc9d5e..2d70982 100644
--- a/backend/src/backend/gen_insn_selection.hxx
+++ b/backend/src/backend/gen_insn_selection.hxx
@@ -84,3 +84,4 @@ DECL_SELECTION_IR(BRC, UnaryInstruction)
 DECL_SELECTION_IR(BRD, UnaryInstruction)
 DECL_SELECTION_IR(IF, UnaryInstruction)
 DECL_SELECTION_IR(ENDIF, UnaryInstruction)
+DECL_SELECTION_IR(ELSE, UnaryInstruction)
diff --git a/backend/src/ir/function.cpp b/backend/src/ir/function.cpp
index b0df412..9b04503 100644
--- a/backend/src/ir/function.cpp
+++ b/backend/src/ir/function.cpp
@@ -125,7 +125,7 @@ namespace ir {
     }
 
     // Reset the label to block mapping
-    this->labels.resize(last);
+    //this->labels.resize(last);
     foreachBlock([&](BasicBlock &bb) {
       const Instruction *first = bb.getFirstInstruction();
       const LabelInstruction *label = cast<LabelInstruction>(first);
@@ -184,24 +184,24 @@ namespace ir {
       return &bb == this->blocks[0];
   }
 
-  const BasicBlock &Function::getTopBlock(void) const {
+  BasicBlock &Function::getTopBlock(void) const {
     GBE_ASSERT(blockNum() > 0 && blocks[0] != NULL);
     return *blocks[0];
   }
 
-  const BasicBlock &Function::getBottomBlock(void) const {
+  BasicBlock &Function::getBottomBlock(void) {
     const uint32_t n = blockNum();
     GBE_ASSERT(n > 0 && blocks[n-1] != NULL);
     return *blocks[n-1];
   }
 
-  BasicBlock &Function::getBottomBlock(void) {
+  BasicBlock &Function::getBottomBlock(void) const {
     const uint32_t n = blockNum();
     GBE_ASSERT(n > 0 && blocks[n-1] != NULL);
     return *blocks[n-1];
   }
 
-  const BasicBlock &Function::getBlock(LabelIndex label) const {
+  BasicBlock &Function::getBlock(LabelIndex label) const {
     GBE_ASSERT(label < labelNum() && labels[label] != NULL);
     return *labels[label];
   }
@@ -244,7 +244,7 @@ namespace ir {
       }
       if (bb.size() == 0) return;
       Instruction *last = bb.getLastInstruction();
-      if (last->isMemberOf<BranchInstruction>() == false) {
+      if (last->isMemberOf<BranchInstruction>() == false || last->getOpcode() == OP_ENDIF || last->getOpcode() == OP_ELSE) {
         jumpToNext = &bb;
         return;
       }
@@ -309,7 +309,11 @@ namespace ir {
   // Basic Block
   ///////////////////////////////////////////////////////////////////////////
 
-  BasicBlock::BasicBlock(Function &fn) : fn(fn) {
+  BasicBlock::BasicBlock(Function &fn) : needEndif(true), needIf(true), endifLabel(0),
+                                         matchingEndifLabel(0), matchingElseLabel(0),
+                                         thisEndifLabel(0), thisElseLabel(0),
+                                         belongToStructure(false), isStructureExit(false),
+                                         matchingStructureEntry(NULL), fn(fn) {
     this->nextBlock = this->prevBlock = NULL;
   }
 
@@ -324,6 +328,11 @@ namespace ir {
     this->push_back(&insn);
   }
 
+  void BasicBlock::insertAt(iterator pos, Instruction &insn) {
+    insn.setParent(this);
+    this->insert(pos, &insn);
+  }
+
   Instruction *BasicBlock::getFirstInstruction(void) const {
     GBE_ASSERT(this->begin() != this->end());
     const Instruction &insn = *this->begin();
diff --git a/backend/src/ir/function.hpp b/backend/src/ir/function.hpp
index 266e652..6755dad 100644
--- a/backend/src/ir/function.hpp
+++ b/backend/src/ir/function.hpp
@@ -58,6 +58,7 @@ namespace ir {
     ~BasicBlock(void);
     /*! Append a new instruction at the end of the stream */
     void append(Instruction &insn);
+    void insertAt(iterator pos, Instruction &insn);
     /*! Get the parent function */
     Function &getParent(void) { return fn; }
     const Function &getParent(void) const { return fn; }
@@ -81,8 +82,22 @@ namespace ir {
         functor(*curr);
       }
     }
-    set <Register> undefPhiRegs;
     set <Register> definedPhiRegs;
+    set <Register> undefPhiRegs;
+  /* these three are used by structure transforming */
+  public:
+    bool needEndif;
+    bool needIf;
+    LabelIndex endifLabel;
+    LabelIndex matchingEndifLabel;
+    LabelIndex matchingElseLabel;
+    LabelIndex thisEndifLabel;
+    LabelIndex thisElseLabel;
+    bool belongToStructure;
+    bool isStructureExit;
+    BasicBlock *matchingStructureEntry;
+    //BasicBlock *matchingThenExit;
+    std::set<Register> liveout;
   private:
     friend class Function; //!< Owns the basic blocks
     BlockSet predecessors; //!< Incoming blocks
@@ -265,13 +280,13 @@ namespace ir {
     /*! Says if this is the top basic block (entry point) */
     bool isEntryBlock(const BasicBlock &bb) const;
     /*! Get function the entry point block */
-    const BasicBlock &getTopBlock(void) const;
+    BasicBlock &getTopBlock(void) const;
     /*! Get the last block */
-    const BasicBlock &getBottomBlock(void) const;
+    BasicBlock &getBottomBlock(void) const;
     /*! Get the last block */
     BasicBlock &getBottomBlock(void);
     /*! Get block from its label */
-    const BasicBlock &getBlock(LabelIndex label) const;
+    BasicBlock &getBlock(LabelIndex label) const;
     /*! Get the label instruction from its label index */
     const LabelInstruction *getLabelInstruction(LabelIndex index) const;
     /*! Return the number of instructions of the largest basic block */
@@ -340,6 +355,7 @@ namespace ir {
     /*! add the loop info for later liveness analysis */
     void addLoop(const vector<LabelIndex> &bbs, const vector<std::pair<LabelIndex, LabelIndex>> &exits);
     INLINE const vector<Loop * > &getLoops() { return loops; }
+    vector<BasicBlock *> &getBlocks() { return blocks; }
   private:
     friend class Context;           //!< Can freely modify a function
     std::string name;               //!< Function name
diff --git a/backend/src/ir/instruction.cpp b/backend/src/ir/instruction.cpp
index 2d2b34b..213d6dd 100644
--- a/backend/src/ir/instruction.cpp
+++ b/backend/src/ir/instruction.cpp
@@ -345,7 +345,7 @@ namespace ir {
     {
     public:
       INLINE BranchInstruction(Opcode op, LabelIndex labelIndex, Register predicate) {
-        GBE_ASSERT(op == OP_BRA);
+        GBE_ASSERT(op == OP_BRA || op == OP_IF);
         this->opcode = op;
         this->predicate = predicate;
         this->labelIndex = labelIndex;
@@ -353,15 +353,15 @@ namespace ir {
         this->hasLabel = true;
       }
       INLINE BranchInstruction(Opcode op, LabelIndex labelIndex) {
-        GBE_ASSERT(op == OP_BRA);
-        this->opcode = OP_BRA;
+        GBE_ASSERT(op == OP_BRA || op == OP_ELSE || op == OP_ENDIF);
+        this->opcode = op;
         this->labelIndex = labelIndex;
         this->hasPredicate = false;
         this->hasLabel = true;
       }
       INLINE BranchInstruction(Opcode op) {
         GBE_ASSERT(op == OP_RET);
-        this->opcode = OP_RET;
+        this->opcode = op;
         this->hasPredicate = false;
         this->hasLabel = false;
       }
@@ -1600,6 +1600,20 @@ DECL_MEM_FN(GetImageInfoInstruction, const uint8_t, getImageIndex(void), getImag
     return internal::BranchInstruction(OP_BRA, labelIndex, pred).convert();
   }
 
+  // IF
+  Instruction IF(LabelIndex labelIndex, Register pred) {
+    return internal::BranchInstruction(OP_IF, labelIndex, pred).convert();
+  }
+
+  // ELSE
+  Instruction ELSE(LabelIndex labelIndex) {
+    return internal::BranchInstruction(OP_ELSE, labelIndex).convert();
+  }
+  // ENDIF
+  Instruction ENDIF(LabelIndex labelIndex) {
+    return internal::BranchInstruction(OP_ENDIF, labelIndex).convert();
+  }
+
   // RET
   Instruction RET(void) {
     return internal::BranchInstruction(OP_RET).convert();
diff --git a/backend/src/ir/instruction.hpp b/backend/src/ir/instruction.hpp
index 582e22d..0f5c8fa 100644
--- a/backend/src/ir/instruction.hpp
+++ b/backend/src/ir/instruction.hpp
@@ -651,6 +651,12 @@ namespace ir {
   Instruction BRA(LabelIndex labelIndex);
   /*! (pred) bra labelIndex */
   Instruction BRA(LabelIndex labelIndex, Register pred);
+  /*! (pred) if labelIndex */
+  Instruction IF(LabelIndex labelIndex, Register pred);
+  /*! else labelIndex */
+  Instruction ELSE(LabelIndex labelIndex);
+  /*! endif */
+  Instruction ENDIF(LabelIndex labelIndex);
   /*! ret */
   Instruction RET(void);
   /*! load.type.space {dst1,...,dst_valueNum} offset value */
diff --git a/backend/src/ir/instruction.hxx b/backend/src/ir/instruction.hxx
index 587517b..abc984f 100644
--- a/backend/src/ir/instruction.hxx
+++ b/backend/src/ir/instruction.hxx
@@ -93,3 +93,6 @@ DECL_INSN(UPSAMPLE_INT, BinaryInstruction)
 DECL_INSN(UPSAMPLE_LONG, BinaryInstruction)
 DECL_INSN(I64MADSAT, TernaryInstruction)
 DECL_INSN(MAD, TernaryInstruction)
+DECL_INSN(IF, BranchInstruction)
+DECL_INSN(ENDIF, BranchInstruction)
+DECL_INSN(ELSE, BranchInstruction)
diff --git a/backend/src/ir/liveness.cpp b/backend/src/ir/liveness.cpp
index afed476..40dfa3f 100644
--- a/backend/src/ir/liveness.cpp
+++ b/backend/src/ir/liveness.cpp
@@ -97,6 +97,7 @@ namespace ir {
       this->initInstruction(*info, insn);
     });
     liveness[&bb] = info;
+    info->liveOut.insert(bb.liveout.begin(), bb.liveout.end());
   }
 
   void Liveness::initInstruction(BlockInfo &info, const Instruction &insn) {
@@ -121,9 +122,12 @@ namespace ir {
     while(!workSet.empty()) {
       auto currInfo = *workSet.begin();
       workSet.erase(currInfo);
+      std::set<ir::Register> tmp;
       for (auto currOutVar : currInfo->liveOut)
+      {
         if (!currInfo->varKill.contains(currOutVar))
           currInfo->upwardUsed.insert(currOutVar);
+      }
       bool isChanged = false;
       for (auto prev : currInfo->bb.getPredecessorSet()) {
         BlockInfo *prevInfo = liveness[prev];
diff --git a/backend/src/ir/structural_analysis.cpp b/backend/src/ir/structural_analysis.cpp
new file mode 100644
index 0000000..b5bc9a7
--- /dev/null
+++ b/backend/src/ir/structural_analysis.cpp
@@ -0,0 +1,965 @@
+#include "structural_analysis.hpp"
+
+namespace analysis
+{
+  ControlTree::~ControlTree()
+  {
+    NodeVector::iterator iter = nodes.begin();
+    NodeVector::iterator iter_end = nodes.end();
+    while(iter != iter_end)
+    {
+      delete *iter;
+      iter++;
+    }
+  }
+
+  void ControlTree::markNeedIf(Node *node, bool status)
+  {
+    if(node->type() == BasicBlock)
+    {
+      ir::BasicBlock* bb = ((BasicBlockNode*)node)->getBasicBlock();
+      bb->needIf = status;
+      return;
+    }
+    NodeList::iterator it = node->children.begin();
+    while(it != node->children.end())
+    {
+      markNeedIf(*it,status);
+      it++;
+    }
+  }
+
+  void ControlTree::markNeedEndif(Node *node, bool status)
+  {
+    if(node->type() == BasicBlock)
+    {
+      ir::BasicBlock* bb = ((BasicBlockNode*)node)->getBasicBlock();
+      bb->needEndif = status;
+      return;
+    }
+
+    NodeList::iterator it = node->children.begin();
+    while(it != node->children.end())
+    {
+      markNeedEndif(*it, status);
+      it++;
+    }
+  }
+
+  void ControlTree::markStructuredNodes(Node *node, bool status)
+  {
+    if(node->type() == BasicBlock)
+    {
+      BasicBlockNode* pbb = static_cast<BasicBlockNode *>(node);
+      pbb->getBasicBlock()->belongToStructure = true;
+    }
+    node->mark = status;
+    NodeList::iterator it = node->children.begin();
+    while(it != node->children.end())
+    {
+      markStructuredNodes(*it, status);
+      it++;
+    }
+  }
+
+  void ControlTree::handleIfNode(Node *node, ir::LabelIndex& matchingEndifLabel, ir::LabelIndex& matchingElseLabel)
+  {
+    ir::BasicBlock *pbb = node->getExit();
+    ir::BranchInstruction* pinsn = static_cast<ir::BranchInstruction *>(pbb->getLastInstruction());
+    ir::Register reg = pinsn->getPredicateIndex();
+    ir::BasicBlock::iterator it = pbb->end();
+    it--;
+    pbb->erase(it);
+    ir::Instruction insn = ir::IF(matchingElseLabel, reg);
+    ir::Instruction* p_new_insn = pbb->getParent().newInstruction(insn);
+    pbb->append(*p_new_insn);
+    pbb->matchingEndifLabel = matchingEndifLabel;
+    pbb->matchingElseLabel = matchingElseLabel;
+  }
+
+  void ControlTree::handleThenNode(Node *node, ir::LabelIndex& endiflabel)
+  {
+    ir::BasicBlock *pbb = node->getExit();
+    ir::BasicBlock::iterator it = pbb->end();
+    it--;
+    ir::Instruction *p_last_insn = pbb->getLastInstruction();
+
+    endiflabel = fn->newLabel();
+    pbb->thisEndifLabel = endiflabel;
+
+    ir::Instruction insn = ir::ENDIF(endiflabel);
+    ir::Instruction* p_new_insn = pbb->getParent().newInstruction(insn);
+    bool append_bra = false;
+    if((*it).getOpcode() == ir::OP_BRA)
+    {
+      pbb->erase(it);
+      append_bra = true;
+    }
+    pbb->append(*p_new_insn);
+    if(append_bra)
+      pbb->append(*p_last_insn);
+  }
+
+
+  void ControlTree::handleThenNode2(Node *node, Node *elsenode, ir::LabelIndex elseBBLabel)
+  {
+    ir::BasicBlock *pbb = node->getExit();
+    ir::BasicBlock::iterator it = pbb->end();
+    it--;
+    if((*it).getOpcode() == ir::OP_BRA)
+      pbb->erase(it);
+    //ir::BasicBlock &tmpbb = fn->getBlock(elseBBLabel);
+    //tmpbb.matchingThenExit = pbb;
+
+    if(node->getExit()->getNextBlock() == elsenode->getEntry())
+      return;
+
+    ir::Instruction insn = ir::BRA(elseBBLabel);
+    ir::Instruction* p_new_insn = pbb->getParent().newInstruction(insn);
+    pbb->append(*p_new_insn);
+  }
+
+
+  void ControlTree::handleElseNode(Node* node, ir::LabelIndex& elselabel, ir::LabelIndex& endiflabel)
+  {
+    handleThenNode(node, endiflabel);
+
+    ir::BasicBlock *pbb = node->getEntry();
+    ir::BasicBlock::iterator it = pbb->begin();
+    it++;
+
+    elselabel = fn->newLabel();
+    pbb->thisElseLabel = elselabel;
+
+    ir::Instruction insn = ir::ELSE(endiflabel);
+    ir::Instruction* p_new_insn = pbb->getParent().newInstruction(insn);
+
+    pbb->insertAt(it, *p_new_insn);
+  }
+
+
+  void ControlTree::handleStructuredNodes()
+  {
+    NodeVector::iterator it;
+    NodeVector::iterator end = nodes.end();
+    NodeVector::iterator begin = nodes.begin();
+    it = end;
+    it--;
+    NodeVector::reverse_iterator rit = nodes.rbegin();
+    while(rit != nodes.rend())
+    {
+      if((*rit)->type() == IfThen || (*rit)->type() == IfElse)
+      {
+        if(false == (*rit)->mark && (*rit)->canBeHandled)
+        {
+          markStructuredNodes(*rit, true);
+          markNeedEndif(*rit, false);
+          markNeedIf(*rit, false);
+          ir::BasicBlock* entry = (*rit)->getEntry();
+          ir::BasicBlock* eexit = (*rit)->getExit();
+          entry->needIf = true;
+          eexit->needEndif = true;
+          entry->endifLabel = fn->newLabel();
+          eexit->endifLabel = entry->endifLabel;
+          eexit->isStructureExit = true;
+          eexit->matchingStructureEntry = entry;
+        }
+      }
+      rit++;
+    }
+
+    rit = nodes.rbegin();
+    gbe::vector<ir::BasicBlock *> &blocks = fn->getBlocks();
+    std::vector<ir::BasicBlock *> bbs;
+    bbs.resize(blocks.size());
+
+    /* here insert the bras to simplify the reorder of basic blocks */
+    for(size_t i = 0; i < blocks.size(); ++i)
+    {
+      bbs[i] = blocks[i];
+      if(bbs[i]->getLastInstruction()->getOpcode() != ir::OP_BRA && i != blocks.size() - 1)
+      {
+        ir::Instruction insn = ir::BRA(bbs[i]->getNextBlock()->getLabelIndex());
+        ir::Instruction* pNewInsn = bbs[i]->getParent().newInstruction(insn);
+        bbs[i]->append(*pNewInsn);
+      }
+    }
+
+    /* now, reorder the basic blocks to reduce the unconditional jump and shorten *
+     * the register liveness in some occasions                                    */
+    while(rit != nodes.rend())
+    {
+      if(((*rit)->type() == IfThen || (*rit)->type() == IfElse || (*rit)->type() == Block) &&
+          (*rit)->canBeHandled && (*rit)->mark == true)
+      {
+        markStructuredNodes(*rit, false);
+        std::set<int> ns = getStructureBasicBlocksIndex(*rit, bbs);
+        ir::BasicBlock *entry = (*it)->getEntry();
+
+        int entryIndex = *(ns.begin());
+        for(size_t i=0; i<bbs.size(); ++i)
+        {
+          if(bbs[i] == entry)
+            entryIndex = i;
+        }
+
+        std::set<int>::iterator iter = ns.begin();
+        int index = *iter;
+
+        std::vector<ir::BasicBlock *> unstruSeqHead;
+        std::vector<ir::BasicBlock *> unstruSeqTail;
+
+        iter = ns.begin();
+        while(iter != ns.end())
+        {
+          if(index != *iter)
+          {
+            if(index < entryIndex)
+              unstruSeqHead.push_back(bbs[index]);
+            else
+              unstruSeqTail.push_back(bbs[index]);
+            index++;
+          }
+          else
+          {
+            index++;
+            iter++;
+          }
+        }
+
+        std::vector<ir::BasicBlock *> struSeq;
+        getStructureSequence(*rit, struSeq);
+
+        int firstindex = *(ns.begin());
+        for(size_t i = 0; i < unstruSeqHead.size(); ++i)
+          bbs[firstindex++] = unstruSeqHead[i];
+        for(size_t i = 0; i < struSeq.size(); ++i)
+          bbs[firstindex++] = struSeq[i];
+        for(size_t i = 0; i < unstruSeqTail.size(); ++i)
+          bbs[firstindex++] = unstruSeqTail[i];
+      }
+      rit++;
+    }
+
+   /* now, erase the BRAs inserted before whose targets are their fallthrough blocks */
+    for(size_t i=0; i<bbs.size(); ++i)
+    {
+      if(bbs[i]->getLastInstruction()->getOpcode() == ir::OP_BRA &&
+         !((ir::BranchInstruction*)(bbs[i]->getLastInstruction()))->isPredicated())
+      {
+        if(((ir::BranchInstruction *)bbs[i]->getLastInstruction())->getLabelIndex() == bbs[i+1]->getLabelIndex())
+        {
+          ir::BasicBlock::iterator it= bbs[i]->end();
+          it--;
+
+          bbs[i]->erase(it);
+        }
+      }
+    }
+    for(size_t i=0; i<bbs.size(); ++i)
+      blocks[i] = bbs[i];
+
+    fn->sortLabels();
+    fn->computeCFG();
+
+#if 1
+    it = begin;
+    while(it != end)
+    {
+      if((*it)->canBeHandled)
+      {
+        switch((*it)->type())
+        {
+          case IfThen:
+            {
+              NodeList::iterator child_iter = (*it)->children.end();
+              ir::LabelIndex endiflabel;
+              child_iter--;
+              handleThenNode(*child_iter, endiflabel);
+              child_iter--;
+              handleIfNode(*child_iter, endiflabel, endiflabel);
+            }
+            break;
+
+          case IfElse:
+            {
+              NodeList::iterator child_iter = (*it)->children.end();
+              ir::LabelIndex endiflabel;
+              ir::LabelIndex elselabel;
+              NodeList::iterator else_node;
+              child_iter--;
+              else_node = child_iter;
+              handleElseNode(*child_iter, elselabel, endiflabel);
+              ir::LabelIndex elseBBLabel = (*child_iter)->getEntry()->getLabelIndex();
+              child_iter--;
+              handleThenNode2(*child_iter, *else_node, elseBBLabel);
+              child_iter--;
+              handleIfNode(*child_iter, endiflabel, elselabel);
+            }
+            break;
+
+          default:
+            break;
+        }
+      }
+
+      it++;
+    }
+#endif
+
+  }
+
+  void ControlTree::getStructureSequence(Node *node, std::vector<ir::BasicBlock*> &seq)
+  {
+    if(node->type() == BasicBlock)
+    {
+      seq.push_back(((BasicBlockNode *)node)->getBasicBlock());
+      return;
+    }
+
+    NodeList::iterator iter = node->children.begin();
+    while(iter != node->children.end())
+    {
+      getStructureSequence(*iter, seq);
+      iter++;
+    }
+
+  }
+
+
+  std::set<int> ControlTree::getStructureBasicBlocksIndex(Node* node, std::vector<ir::BasicBlock *> &bbs)
+  {
+    std::set<int> result;
+    if(node->type() == BasicBlock)
+    {
+      for(size_t i=0; i<bbs.size(); i++)
+      {
+        if(bbs[i] == ((BasicBlockNode *)node)->getBasicBlock())
+        {
+          result.insert(i);
+          break;
+        }
+      }
+      return result;
+    }
+    NodeList::iterator iter = (node->children).begin();
+    NodeList::iterator end = (node->children).end();
+    while(iter != end)
+    {
+      std::set<int> ret = getStructureBasicBlocksIndex(*iter, bbs);
+      result.insert(ret.begin(), ret.end());
+      iter++;
+    }
+    return result;
+  }
+
+
+  std::set<ir::BasicBlock *> ControlTree::getStructureBasicBlocks(Node *node)
+  {
+    std::set<ir::BasicBlock *> result;
+    if(node->type() == BasicBlock)
+    {
+      result.insert(((BasicBlockNode *)node)->getBasicBlock());
+      return result;
+    }
+    NodeList::iterator iter = (node->children).begin();
+    NodeList::iterator end = (node->children).end();
+    while(iter != end)
+    {
+      std::set<ir::BasicBlock *> ret = getStructureBasicBlocks(*iter);
+      result.insert(ret.begin(), ret.end());
+      iter++;
+    }
+    return result;
+  }
+
+
+  Node* ControlTree::insertNode(Node *p_node)
+  {
+    nodes.push_back(p_node);
+    return p_node;
+  }
+
+
+  bool ControlTree::checkForBarrier(const ir::BasicBlock* bb)
+  {
+    ir::BasicBlock::const_iterator iter = bb->begin();
+    ir::BasicBlock::const_iterator iter_end = bb->end();
+    while(iter != iter_end)
+    {
+      if((*iter).getOpcode() == ir::OP_SYNC)
+        return true;
+      iter++;
+    }
+
+    return false;
+  }
+
+
+  void ControlTree::getLiveIn(ir::BasicBlock& bb, std::set<ir::Register>& livein)
+  {
+    ir::BasicBlock::iterator iter = bb.begin();
+    std::set<ir::Register> varKill;
+    while(iter != bb.end())
+    {
+      ir::Instruction& insn = *iter;
+      const uint32_t srcNum = insn.getSrcNum();
+      const uint32_t dstNum = insn.getDstNum();
+      for(uint32_t srcID = 0; srcID < srcNum; ++srcID)
+      {
+        const ir::Register reg = insn.getSrc(srcID);
+        if(varKill.find(reg) == varKill.end())
+          livein.insert(reg);
+      }
+      for(uint32_t dstID = 0; dstID < dstNum; ++dstID)
+      {
+        const ir::Register reg = insn.getDst(dstID);
+        varKill.insert(reg);
+      }
+
+      iter++;
+    }
+  }
+
+  void ControlTree::calculateNecessaryLiveout()
+  {
+    NodeVector::iterator iter = nodes.begin();
+
+    while(iter != nodes.end())
+    {
+      switch((*iter)->type())
+      {
+        case IfElse:
+        {
+          std::set<ir::BasicBlock *> bbs;
+          bbs = getStructureBasicBlocks(*iter);
+
+          Node *elseNode = *((*iter)->children.rbegin());
+          std::set<ir::Register> livein;
+          getLiveIn(*(elseNode->getEntry()), livein);
+
+          std::set<ir::BasicBlock *>::iterator bbiter = bbs.begin();
+          while(bbiter != bbs.end())
+          {
+            (*bbiter)->liveout.insert(livein.begin(), livein.end());
+            bbiter++;
+          }
+        }
+
+        default:
+          break;
+      }
+      iter++;
+    }
+  }
+
+
+  void ControlTree::initializeNodes()
+  {
+    ir::BasicBlock& tmp_bb = fn->getTopBlock();
+    ir::BasicBlock* p_tmp_bb = &tmp_bb;
+    Node* p = NULL;
+
+    if(NULL != p_tmp_bb)
+    {
+      Node *p_tmp_node = new BasicBlockNode(p_tmp_bb);
+      p_tmp_node->label = p_tmp_bb->getLabelIndex();
+
+      if(checkForBarrier(p_tmp_bb))
+        p_tmp_node->hasBarrier() = true;
+
+      nodes.push_back(p_tmp_node);
+      bbmap[p_tmp_bb] = p_tmp_node;
+      p_tmp_bb = p_tmp_bb->getNextBlock();
+      p = p_tmp_node;
+    }
+
+    while(p_tmp_bb != NULL)
+    {
+      Node *p_tmp_node = new BasicBlockNode(p_tmp_bb);
+      p_tmp_node->label = p_tmp_bb->getLabelIndex();
+
+      if(checkForBarrier(p_tmp_bb))
+        p_tmp_node->hasBarrier() = true;
+
+      p->fallthrough() = p_tmp_node;
+      p = p_tmp_node;
+      nodes.push_back(p_tmp_node);
+      bbmap[p_tmp_bb] = p_tmp_node;
+      p_tmp_bb = p_tmp_bb->getNextBlock();
+    }
+
+    if(NULL != p)
+      p->fallthrough() = NULL;
+
+    p_tmp_bb = &tmp_bb;
+
+    this->nodes_entry = bbmap[p_tmp_bb];
+
+    while(p_tmp_bb != NULL)
+    {
+      ir::BlockSet::const_iterator iter_begin = p_tmp_bb->getPredecessorSet().begin();
+      ir::BlockSet::const_iterator iter_end = p_tmp_bb->getPredecessorSet().end();
+      while(iter_begin != iter_end)
+      {
+        bbmap[p_tmp_bb]->preds().insert(bbmap[*iter_begin]);
+        iter_begin++;
+      }
+
+      iter_begin = p_tmp_bb->getSuccessorSet().begin();
+      iter_end = p_tmp_bb->getSuccessorSet().end();
+      while(iter_begin != iter_end)
+      {
+        bbmap[p_tmp_bb]->succs().insert(bbmap[*iter_begin]);
+        iter_begin++;
+      }
+
+      p_tmp_bb = p_tmp_bb->getNextBlock();
+    }
+  }
+
+
+  void ControlTree::DFSPostOrder(Node *start)
+  {
+    visited.insert(start);
+    NodeSet::iterator y;
+    NodeSet::iterator iter_begin = start->succs().begin();
+    NodeSet::iterator iter_end = start->succs().end();
+    for(y = iter_begin; y != iter_end; ++y )
+    {
+      if(visited.find(*y) != visited.end())
+        continue;
+      DFSPostOrder(*y);
+    }
+    post_order.push_back(start);
+  }
+
+
+  bool ControlTree::isCyclic(Node* node)
+  {
+    if(node->type() == NaturalLoop ||
+       node->type() == WhileLoop ||
+       node->type() == SelfLoop)
+      return true;
+
+    return false;
+  }
+
+
+  bool ControlTree::isBackedge(const Node* head, const Node* tail)
+  {
+    const Node* match[] = {head, tail};
+    NodeList::iterator n = find_first_of(post_order.begin(), post_order.end(), match, match + 2);
+
+    if(*n == head)
+      return true;
+    if(*n == tail)
+      return false;
+
+    return false;
+  }
+
+
+  bool ControlTree::pathBack(Node* m, Node* n)
+  {
+    for(NodeSet::const_iterator iter = n->preds().begin(); iter!= n->preds().end(); iter++)
+    {
+      if(isBackedge(*iter, n))
+      {
+        visited.clear();
+        if(path(m, *iter, n))
+          return true;
+      }
+    }
+
+    return false;
+  }
+
+  /* totally textbook */
+  Node* ControlTree::acyclicRegionType(Node* node, NodeSet& nset)
+  {
+    nset.clear();
+    Node *n;
+    bool p, s, barrier;
+    NodeList nodes;
+
+    n = node;
+    p = true;
+    s = (n->succs().size()==1);
+    barrier = n->hasBarrier();
+    while(p && s && !barrier)
+    {
+      if(nset.insert(n).second)
+        nodes.push_back(n);
+      n = *(n->succs().begin());
+      barrier = n->hasBarrier();
+      p = (n->preds().size() == 1);
+      s = (n->succs().size() == 1);
+    }
+
+    if(p && !barrier)
+    {
+      if(nset.insert(n).second)
+        nodes.push_back(n);
+    }
+
+    n = node;
+    p = (n->preds().size() == 1);
+    s = true;
+    barrier = n->hasBarrier();
+
+    while(p && s && !barrier)
+    {
+      if(nset.insert(n).second)
+        nodes.push_front(n);
+      n = *(n->preds().begin());
+      barrier = n->hasBarrier();
+      p = (n->preds().size() == 1);
+      s = (n->succs().size() == 1);
+    }
+
+    if(s && !barrier)
+    {
+      if(nset.insert(n).second)
+        nodes.push_front(n);
+    }
+
+    node = n;
+
+    if(nodes.size() >=2 )
+    {
+      Node* p = new BlockNode(nodes);
+      NodeList::iterator iter = nodes.begin();
+      while(iter != nodes.end())
+      {
+        if((*iter)->canBeHandled == false)
+        {
+          p->canBeHandled = false;
+          break;
+        }
+        iter++;
+      }
+
+      return insertNode(p);
+    }
+
+    else if(node->succs().size() == 2)
+    {
+      Node *m;
+      m = *(node->succs().begin());
+      n = *(++(node->succs().begin()));
+
+      /* check for if node then n */
+      if(n->succs().size() == 1 &&
+         n->preds().size() == 1 &&
+         *(n->succs().begin()) == m &&
+         !n->hasBarrier() && !node->hasBarrier())
+      {
+        nset.clear();
+        nset.insert(node);
+        nset.insert(n);
+
+        Node* p = new IfThenNode(node, n);
+
+        if(node->canBeHandled == false || n->canBeHandled == false)
+          p->canBeHandled = false;
+
+        return insertNode(p);
+      }
+
+      /* check for if node then m */
+      if(m->succs().size() == 1 &&
+         m->preds().size() == 1 &&
+         *(m->succs().begin()) == n &&
+         !m->hasBarrier() && !node->hasBarrier())
+      {
+        nset.clear();
+        nset.insert(node);
+        nset.insert(m);
+
+        Node* p = new IfThenNode(node, m);
+
+        if(node->canBeHandled == false || m->canBeHandled == false)
+          p->canBeHandled = false;
+
+        return insertNode(p);
+      }
+
+      /* check for if node then n else m */
+      if(m->succs().size() == 1 && n->succs().size() == 1 &&
+         m->preds().size() == 1 && n->preds().size() == 1 &&
+         *(m->succs().begin()) == *(n->succs().begin()) &&
+         node->fallthrough() == n && !m->hasBarrier() && !n->hasBarrier() && !node->hasBarrier())
+      {
+        nset.clear();
+        nset.insert(node);
+        nset.insert(n);
+        nset.insert(m);
+
+        Node* p = new IfElseNode(node, n, m);
+
+        if(node->canBeHandled == false ||
+           m->canBeHandled == false ||
+           n->canBeHandled == false)
+          p->canBeHandled = false;
+
+        return insertNode(p);
+      }
+
+      /* check for if node then m else n */
+      if(m->succs().size() == 1 && n->succs().size() == 1 &&
+         m->preds().size() == 1 && n->preds().size() == 1 &&
+         *(m->succs().begin()) == *(n->succs().begin()) &&
+         node->fallthrough() == m && !m->hasBarrier() && !n->hasBarrier() &&!node->hasBarrier())
+      {
+        nset.clear();
+        nset.insert(node);
+        nset.insert(m);
+        nset.insert(n);
+
+        Node* p = new IfElseNode(node, m, n);
+
+        if(node->canBeHandled == false ||
+           m->canBeHandled == false ||
+           n->canBeHandled == false)
+          p->canBeHandled = false;
+        return insertNode(p);
+      }
+    }
+
+    return NULL;
+  }
+
+
+  bool ControlTree::path(Node *from, Node *to, Node *notthrough)
+  {
+
+    if(from == notthrough || visited.find(from) != visited.end())
+      return false;
+
+    if(from == to)
+      return true;
+
+    visited.insert(from);
+
+    for(NodeSet::const_iterator s = from->succs().begin(); s != from->succs().end(); s++)
+    {
+      if(path(*s, to, notthrough))
+        return true;
+    }
+
+    return false;
+  }
+
+
+  Node * ControlTree::cyclicRegionType(Node *node, NodeList &nset)
+  {
+#if 0
+    /* check for self-loop */
+    if(nset.size() == 1)
+    {
+      if(node->succs().find(node) != node->succs().end())
+      {
+        Node* p = new SelfLoopNode(node);
+
+        p->canBeHandled = false;
+
+        return insertNode(p);
+      }
+      else
+        return NULL;
+    }
+
+    /* check for improper region */
+    for(NodeList::const_iterator m = nset.begin(); m != nset.end(); m++)
+    {
+      visited.clear();
+      if(!path(node, *m))
+        return NULL;
+    }
+
+    /* check for while loop */
+    NodeList::iterator m;
+    for(m = nset.begin(); m != nset.end(); ++m)
+    {
+      if(*m == node)
+        continue;
+      if(node->succs().size() == 2 && (*m)->succs().size() == 1 &&
+         node->preds().size() == 2 && (*m)->preds().size() == 1)
+      {
+        Node* p = new WhileLoopNode(node, *m);
+
+        p->canBeHandled = false;
+
+        return insertNode(p);
+      }
+    }
+#endif
+    return NULL;
+  }
+
+
+  void ControlTree::reduce(Node* node,  NodeSet nodeSet)
+  {
+    NodeSet::iterator n;
+    for(n = nodeSet.begin(); n != nodeSet.end(); n++)
+    {
+      NodeSet::iterator p;
+      for(p = (*n)->preds().begin(); p != (*n)->preds().end(); p++)
+      {
+        if(nodeSet.find(*p) != nodeSet.end())
+          continue;
+
+        (*p)->succs().erase(*n);
+
+        (*p)->succs().insert(node);
+        node->preds().insert(*p);
+
+        if((*p)->fallthrough() == *n)
+          (*p)->fallthrough() = node;
+      }
+
+
+     NodeSet::iterator s;
+     for(s = (*n)->succs().begin(); s != (*n)->succs().end(); s++)
+     {
+        if(nodeSet.find(*s) != nodeSet.end())
+          continue;
+
+       (*s)->preds().erase(*n);
+
+       (*s)->preds().insert(node);
+       node->succs().insert(*s);
+
+       if((*n)->fallthrough() == *s)
+         node->fallthrough() = *s;
+     }
+    }
+
+    if(!isCyclic(node))
+    {
+      for(n = nodeSet.begin(); n != nodeSet.end(); n++)
+      {
+        bool shouldbreak = false;
+        NodeSet::iterator p;
+        for(p = (*n)->preds().begin(); p != (*n)->preds().end(); p++)
+        {
+          if(nodeSet.find(*p) == nodeSet.end())
+            continue;
+
+          if(isBackedge(*p, *n))
+          {
+            node->preds().insert(node);
+            node->succs().insert(node);
+
+            shouldbreak = true;
+            break;
+          }
+        }
+
+        if(shouldbreak)
+          break;
+      }
+    }
+
+    compact(node, nodeSet);
+  }
+
+
+  void ControlTree::compact(Node* node,  NodeSet nodeSet)
+  {
+    NodeList::iterator n, pos;
+    for(n = post_order.begin(); n!= post_order.end() && !nodeSet.empty();)
+    {
+      if(!nodeSet.erase(*n))
+      {
+        n++;
+        continue;
+      }
+
+      n = post_order.erase(n);
+      pos = n;
+    }
+
+    post_ctr = post_order.insert(pos, node);
+  }
+
+
+  void ControlTree::structuralAnalysis(Node *entry)
+  {
+    Node* n;
+    NodeSet nset;
+    NodeList reachUnder;
+    bool changed;
+    do
+    {
+      changed = false;
+      post_order.clear();
+      visited.clear();
+
+      DFSPostOrder(entry);
+      post_ctr = post_order.begin();
+
+      while(post_order.size() > 1 && post_ctr != post_order.end())
+      {
+        n = *post_ctr;
+        Node* region = acyclicRegionType(n, nset);
+
+        if( NULL != region)
+        {
+          changed = true;
+
+          reduce(region, nset);
+
+          if(nset.find(entry) != nset.end())
+            entry = region;
+        }
+        else
+        {
+#if 0
+          reachUnder.clear();
+          nset.clear();
+          for(NodeList::const_iterator m = post_order.begin(); m != post_order.end(); m++)
+          {
+            if(*m != n && pathBack(*m, n))
+            {
+              reachUnder.push_front(*m);
+              nset.insert(*m);
+            }
+          }
+
+          reachUnder.push_front(n);
+          nset.insert(n);
+          region = cyclicRegionType(n, reachUnder);
+
+          if(NULL != region)
+          {
+            reduce(region, nset);
+            changed = true;
+
+            if(nset.find(entry) != nset.end())
+              entry = region;
+          }
+          else
+          {
+#endif
+            post_ctr++;
+         // }
+        }
+      }
+
+      if(!changed)
+        break;
+
+    } while(post_order.size()>1);
+
+  }
+
+  void ControlTree::analyze()
+  {
+    initializeNodes();
+    structuralAnalysis(nodes_entry);
+    handleStructuredNodes();
+    calculateNecessaryLiveout();
+  }
+}
diff --git a/backend/src/ir/structural_analysis.hpp b/backend/src/ir/structural_analysis.hpp
new file mode 100644
index 0000000..8ac79f8
--- /dev/null
+++ b/backend/src/ir/structural_analysis.hpp
@@ -0,0 +1,250 @@
+#ifndef __STRUCTURAL_ANALYSIS_HPP__
+#define __STRUCTURAL_ANALYSIS_HPP__
+
+#include "ir/unit.hpp"
+#include "ir/function.hpp"
+#include "ir/instruction.hpp"
+
+#include <iostream>
+#include <unordered_set>
+#include <unordered_map>
+#include <vector>
+#include <map>
+#include <list>
+#include <algorithm>
+#include <set>
+#define TRANSFORM_UNSTRUCTURE
+
+namespace analysis
+{
+  using namespace std;
+  using namespace gbe;
+
+  enum RegionType
+  {
+    BasicBlock = 0,
+    Block,
+    IfThen,
+    IfElse,
+    SelfLoop,
+    WhileLoop,
+    NaturalLoop
+  } ;
+
+  /* control tree virtual node */
+  class Node;
+
+  typedef unordered_set<Node *> NodeSet;
+  typedef list<Node *> NodeList;
+  typedef std::vector<Node *> NodeVector;
+
+  /* control tree virtual node */
+  class Node
+  {
+  public:
+    Node(RegionType rtype, const NodeList& children): has_barrier(false), mark(false), canBeHandled(true)
+    {
+      this->rtype = rtype;
+      this->children = children;
+    }
+    virtual ~Node() {}
+    NodeSet& preds() { return pred; }
+    NodeSet& succs() { return succ; }
+    Node*& fallthrough() { return fall_through; }
+    bool& hasBarrier() { return has_barrier; }
+    RegionType type() { return rtype; }
+    virtual ir::BasicBlock* getEntry()
+    {
+      return (*(children.begin()))->getEntry();
+    }
+    virtual ir::BasicBlock* getExit()
+    {
+      return (*(children.rbegin()))->getExit();
+    }
+
+  public:
+    RegionType rtype;
+    NodeSet pred;
+    NodeSet succ;
+    NodeList children;
+    Node* fall_through;
+    bool has_barrier;
+    bool mark;
+    bool canBeHandled;
+    //label is for debug
+    int label;
+  };
+
+  /* represents basic block */
+  class BasicBlockNode : public Node
+  {
+  public:
+    BasicBlockNode(ir::BasicBlock *p_bb) : Node(BasicBlock, NodeList()) { this->p_bb = p_bb; }
+    virtual ~BasicBlockNode() {}
+    ir::BasicBlock* getBasicBlock() { return p_bb; }
+    virtual ir::BasicBlock* getEntry() { return p_bb; }
+    virtual ir::BasicBlock* getExit() { return p_bb; }
+    virtual ir::BasicBlock* getFirstBB() { return p_bb; }
+  private:
+    ir::BasicBlock *p_bb;
+  };
+
+  /* a sequence of nodes */
+  class BlockNode : public Node
+  {
+  public:
+    BlockNode(NodeList& children) : Node(Block, children) {}
+    virtual ~BlockNode(){}
+  };
+
+  /* If-Then structure node */
+  class IfThenNode : public Node
+  {
+  public:
+    IfThenNode(Node* cond, Node* ifTrue) : Node(IfThen, BuildChildren(cond, ifTrue)) {}
+    virtual ~IfThenNode() {}
+
+  private:
+    const NodeList BuildChildren(Node* cond, Node* ifTrue)
+    {
+      NodeList children;
+      children.push_back(cond);
+      children.push_back(ifTrue);
+      return children;
+    }
+  };
+
+  /* If-Else structure node */
+  class IfElseNode : public Node
+  {
+  public:
+    IfElseNode(Node* cond, Node* ifTrue, Node* ifFalse) : Node(IfElse, BuildChildren(cond, ifTrue, ifFalse)) {}
+    virtual ~IfElseNode() {}
+
+  private:
+    const NodeList BuildChildren(Node* cond, Node* ifTrue, Node* ifFalse)
+    {
+      NodeList children;
+      children.push_back(cond);
+      children.push_back(ifTrue);
+      children.push_back(ifFalse);
+      return children;
+    }
+  };
+#if 0
+  /* Self loop structure node */
+  class SelfLoopNode : public Node
+  {
+  public:
+    SelfLoopNode(Node* node) : Node(SelfLoop, BuildChildren(node)) {}
+    virtual ~SelfLoopNode() {}
+    virtual ir::BasicBlock* getEntry()
+    {
+      return (*(children.begin()))->getEntry();
+    }
+    virtual ir::BasicBlock* getExit()
+    {
+      return (*(children.begin()))->getExit();
+    }
+
+  private:
+    const NodeList BuildChildren(Node *node)
+    {
+      NodeList children;
+      children.push_back(node);
+      return children;
+    }
+  };
+
+  /* While loop structure node */
+  class WhileLoopNode : public Node
+  {
+  public:
+    WhileLoopNode(Node* cond, Node* execute) : Node(WhileLoop, BuildChildren(cond, execute)) {}
+    virtual ~WhileLoopNode() {}
+    virtual ir::BasicBlock* getEntry()
+    {
+      return (*(children.begin()))->getEntry();
+    }
+    virtual ir::BasicBlock* getExit()
+    {
+      return (*(children.begin()))->getExit();
+    }
+
+  private:
+    const NodeList BuildChildren(Node* cond, Node* execute)
+    {
+      NodeList children;
+      children.push_back(cond);
+      children.push_back(execute);
+      return children;
+    }
+
+  };
+
+  /* Natural loop structure node */
+  class NaturalLoopNode : public Node
+  {
+  public:
+    NaturalLoopNode(const NodeList& children): Node(NaturalLoop, children){}
+    virtual ~NaturalLoopNode() {}
+    virtual ir::BasicBlock* getEntry()
+    {
+      //TODO implement it
+      return NULL;
+    }
+    virtual ir::BasicBlock* getExit()
+    {
+      //TODO implement it
+      return NULL;
+    }
+  };
+#endif
+  /* computes the control tree, and do the structure transform during the computation */
+  class ControlTree
+  {
+  public:
+    void analyze();
+
+    ControlTree(ir::Function* fn) { this->fn = fn; }
+    ~ControlTree();
+
+  private:
+    void initializeNodes();
+    Node* insertNode(Node *);
+    void structuralAnalysis(Node * entry);
+    void DFSPostOrder(Node *start);
+    bool path(Node *, Node *, Node *notthrough = NULL);
+    void reduce(Node* node,  NodeSet nodeSet);
+    void compact(Node* node,  NodeSet nodeSet);
+    Node* getNodesEntry() const  { return nodes_entry;}
+    Node* acyclicRegionType(Node*, NodeSet&);
+    Node* cyclicRegionType(Node*, NodeList&);
+    bool isCyclic(Node*);
+    bool isBackedge(const Node*, const Node*);
+    bool pathBack(Node*, Node*);
+    bool checkForBarrier(const ir::BasicBlock*);
+    void markStructuredNodes(Node *, bool);
+    void markNeedEndif(Node *, bool);
+    void markNeedIf(Node *, bool);
+    void handleIfNode(Node *, ir::LabelIndex&, ir::LabelIndex&);
+    void handleThenNode(Node *, ir::LabelIndex&);
+    void handleThenNode2(Node *, Node *, ir::LabelIndex);
+    void handleElseNode(Node *, ir::LabelIndex&, ir::LabelIndex&);
+    void handleStructuredNodes();
+    std::set<int> getStructureBasicBlocksIndex(Node *, std::vector<ir::BasicBlock *> &);
+    std::set<ir::BasicBlock *> getStructureBasicBlocks(Node*);
+    void getLiveIn(ir::BasicBlock& , std::set<ir::Register>& livein);
+    void calculateNecessaryLiveout();
+    void getStructureSequence(Node*, std::vector<ir::BasicBlock*> &);
+  private:
+    ir::Function *fn;
+    NodeVector nodes;
+    Node* nodes_entry;
+    unordered_map<ir::BasicBlock *, Node *> bbmap;
+    NodeList post_order;
+    NodeSet visited;
+    NodeList::iterator post_ctr;
+  };
+}
+#endif
diff --git a/backend/src/llvm/llvm_to_gen.cpp b/backend/src/llvm/llvm_to_gen.cpp
index 9282b3f..13b1ea8 100644
--- a/backend/src/llvm/llvm_to_gen.cpp
+++ b/backend/src/llvm/llvm_to_gen.cpp
@@ -60,6 +60,8 @@
 #include "llvm/llvm_to_gen.hpp"
 #include "sys/cvar.hpp"
 #include "sys/platform.hpp"
+#include "ir/unit.hpp"
+#include "ir/structural_analysis.hpp"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -224,6 +226,18 @@ namespace gbe
 #endif
     passes.run(mod);
 
+#ifdef TRANSFORM_UNSTRUCTURE
+    const ir::Unit::FunctionSet& fs = unit.getFunctionSet();
+    ir::Unit::FunctionSet::const_iterator iter = fs.begin();
+    while(iter != fs.end())
+    {
+      analysis::ControlTree *ct = new analysis::ControlTree(iter->second);
+      ct->analyze();
+      delete ct;
+      iter++;
+    }
+#endif
+
     return true;
   }
 } /* namespace gbe */
-- 
1.8.3.2

